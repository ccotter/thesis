
\section{Kernel Implementation}

With a high level design in mind, we now discuss the final version of the
implementation. We started by forking Linux from a {\tt git} repository, and
worked on x86\_64 Linux 3.0. We developed and tested incrementally on an 8-core
machine with 8 gigabyets of RAM running Arch Linux.

\subsection{Process synchronization}

The first step was adding the three new syscalls: {\tt dput()}, {\tt dget()},
and {\tt dret()}; slowly we added the various features to the syscall
implementations. Our initial focus was adding process creation functionality;
{\tt dput()} relies heavily on existing {\tt fork()} kernel code to create new
processes. We also used existing {\tt do\_exit()} code to delete processes,
and enforce that a deterministic processes death implies the death of its
process subtree. We block all external signals generated by user applications,
but allow signals generated by the kernel itself; it is through this mechanism
that exceptions, such as divide-by-zero faults that generate a {\tt SIGFPE},
cause an implicit {\tt dret()}.

We augment Linux's {\tt task\_struct} process structure with a
\emph{deterministic PID} and synchronization primitives. {\tt dput()} and
{\tt dget()} use these synchronization primitives to correctly synchronize
deterministic process communication within the hybrid process model.

In Determinator, \emph{all} processes that issue a {\tt dput()} or {\tt dget()}
block until the child in question issues a {\tt dret()}. This is a limitation
for applications that benefit from concurrency, such as running
{\tt make -j2}~\cite{Aviram10}. As noted by Aviram et al., Determinator might
miss opportunities to start a parallel job, because a deterministic {\tt make}
in Determinator schedules itself and might be blocked waiting for a thread to
finish when other children are runnable. In our implementation we allow the root
process to perform a special non-blocking {\tt dget()} to determine whether or
not a child is still running. This allows more optimal scheduling, since the
root can find a runnable thread and give it work. Determinism is achieved by
recording the scheduling sequence for replay, if desired. This feature is
desirable for inherently nondeterministic applications like web servers that may
wish to exploit as much concurrency as possible.

\iffalse
\begin{itemize}
	\item Add three new syscalls with basic process creation, synchronization,
		and deletion.
	\begin{itemize}
		\item dput() relies heavily on existing fork() code to generate new processes.
		\item Disallow deterministic process reparenting: a deterministic or root
			process's death implies all children should die as well.
		\item Use existing code for handling process deletion: do\_exit().
		\item Block signals from reaching deterministic processes.
		\item Exceptions (e.g. divide-by-zero) immediately stop the process; parents
			must acknowledge and handle the child's exception.
	\end{itemize}
	\item Loosened root process requirements.
	\begin{itemize}
		\item The root process has the the option of being interrupted by a signal
			while waiting for a child via dput()/dget().
		\item Root processes may poll a children's runnability status to optimize
			scheduling of threads. This introduces non-determinism only for the root
			process which itself already has elevated permissions, but the scheduling
			sequence is still controllable and can be logged for debug replay.
\fi

Root processes can use {\tt dput()} to specify a set of signals to block while
in a blocking {\tt dput()} or {\tt dget()}. Blocking versions of these syscalls
ignore signals specified in the block set sent to the root until the child
issues a {\tt dret()}. This can be useful when a console operation wishes to
kill an application with a {\tt SIGINT}, but does not want other signals to
interrupt the root process.

The last feature relating strictly to process organization is register state
copying. The initial {\tt dput()} call that creates a child automatically
copies register state, since we effectively delegate work to {\tt fork()}.
Subsequent calls to {\tt dput()} and {\tt dget()} pass general purpose register
state structure pointer to set or get a child's register set.

\iffalse
	\end{itemize}
	\item When dput() creates a child, it automatically copies the parent's
		register set into the child. Subsequent dput() calls can set/get a
		child's register state.
\fi

\subsection{Memory operations}

\iffalse
	\item Memory operations are more difficult. Linux's memory subsystem is not
		as generic as I would have liked.
	\begin{itemize}
		\item The kernel supports zeroing an area of virtual memory, but only for
			the current running process that invoked a syscall. Most functionality
			in the memory subsystem works this way and is hardcoded this way.
		\item Before any real work could be done, I generalized some memory functions
			to work on any process (e.g. mmap\_region(), make\_pages\_present()).
		\item The copy\_page\_range() function copies a range of memory via
			copy-on-write, but it is really a helper function for fork() and is
			not very generic.
		\item copy\_page\_range() copies identical virtual memory regions.
		\item I wanted to support copy-on-write with an address offset, so I
			replicated copy\_page\_range()'s page table traversal code to allow
			the destination memory region to be offset by a page aligned amount.
	\end{itemize}
	\item Implementing zero was very simple and straightforward with the newly
		genericized functions. Linux's existing functionality basically installs
		a new vm\_area\_struct region and clears the page tables of that region.
		Any accesses to the region will generate a page fault, and Linux then knows
		to allocate a zeroed page (demand paging).
	\item Special care for boundary conditions if the region is not page aligned.
	\item The copy operation was more complicated: in order for copy-on-write to
		work, vm\_area\_structs need to be aligned.
	\begin{itemize}
		\item Page mappings need to have identical offsets from the start address
			of the vm\_area\_struct in which it is mapped (for swapping).
		\item When preparing to copy-on-write a region, I split the vm\_area\_structs
			if necessary.
		\item I also have to do some additional usage counting; this is not well
			documented, so it took some time to figure out how to properly account.
	\end{itemize}
	\item Snapshot/merge were the most complicated functions, especially since no
		code existed to easily handle what I wanted to accomplish with merge.
	\item Linux's mm\_struct encapsulates a process's entire virtual memory; it
		stores a reference to the page global directory (register \%cr3) and a list
		of vm\_area\_structs, among other things.
	\item mm\_structs are generic enough so that snapshot is implemented by calling
		dup\_mm() twice to essentially make a deep copy of the calling process's
		mm\_struct. One copy is stored in the target process's main mm descriptor,
		the other copy is kept as a reference to the memory image at snapshot time.
	\item Merge works by traversing the four level page table structure and checks
		the reference page table entry to detect conflicts. Page level conflicts
		are dealt by examining pages byte-by-byte, as in Determinator.
	\item All the considerations before applied: merging non page-aligned regions,
		ensuring vm\_area\_structs are aligned by splitting regions when necessary,
		etc.
	\item Special consideration was given for features like transparent huge pages
		when traversing page tables. For transparent huge pages, I call a backup
		function to split the region into normal sized pages, since I did not write
		special code for huge page table traversal.
	\item Complications arose from not following the page table lock
		synchronization rules, calling functions that might sleep in areas of
		code where it is strictly disallowed (atomic regions), and cases such
		as a page being swapped out to disk.
\end{itemize}

\fi

\endinput

	\begin{itemize}
	\end{itemize}

