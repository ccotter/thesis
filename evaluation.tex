
\section{Evaluation}

This section evaluates deterministic Linux by comparing compute-bound
applications run using the new deterministic API and nondeterministic pthreads.
We conclude by considering a case study demonstrating the qualitative debugging
benefits of determinism.

\subsection{Empirical experiments}

Aviram et al. already demonstrated course-grained applications in Determinator
performed comparable to nondeterministic Linux equivalents, but fine-grained
applications did not scale nearly as well, incurring high performance costs
owing to memory synchronization costs.

The primary goal of our evaluations is to determine if Linux can efficiently run
applications using Determinator's programming model. Since the
deterministic Linux API reuses much existing kernel code, we expect reasonable
performance compared to the equivalent nondeterministic application. However,
applications that heavily rely on memory-intensive kernel operations like
Snapshot-Merge might incur performance penalties.

[unfinished]

I tested 3 applications: matrix multiplication, md5 password cracker, merge
sort. Each is course-grained.
I also have a quicksort and LU decomposition, and at the very least I'd like to get
the LU decomposition into the test set since it is fine-grained.

I'm still fine tuning the evaluation programs, but so far I've found that
on ``small'' inputs sizes, the three benchmarks perform with up to ~10x
performance penalties. ``Large'' input sizes incur penalties between 1-2x.
md5 (the most parallelizable and uses the least memory synchronization)
performs very well, but matrix multiplication (uses a lot of memory
synchronization) has considerable overhead.

I'd also like to determine why the perform costs occur (profiling), since I
believe changing implementation of either the syscalls or library routines could
reduce the performance penalties for small input sizes.

I tested on an 8-core machine and ran tests using 1-8 threads.

\subsection{Finding bugs deterministically}

[not finished]

Basically, I wrote a parallel LU decomposition using pthreads and deterministic
Linux but purposely introduced a synchronization bug. I fork N children, but
only join on N-1 children (the bug). The pthreads program sometimes gives the
correct results, other times it doesn't. The deterministic program always gives
the incorrect result.

\endinput

